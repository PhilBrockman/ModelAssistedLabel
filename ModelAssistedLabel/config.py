# AUTOGENERATED! DO NOT EDIT! File to edit: 00_config.ipynb (unless otherwise specified).

__all__ = ['Defaults']

# Cell

import json, os, shutil, ast

class Defaults:
  """
  Makes certain variables are very accessible across the repository. The names
  of the variables and their respective values are stored in JSON format in
  `./ModelAssistedLabel config.json`

  Functions defined here are also available across this project.
  """

  def __init__(self, config_file="ModelAssistedLabel config.json"):
    self.config_file=config_file

    with open(config_file, "r") as f:
      indata = (json.load(f))
    for k,v in indata.items():
      self.__dict__[k] = v

  def to_root(self):
    "move to the root directory"
    assert self.root
    print(f"moving to {self.root}")
    os.chdir(self.root)

  def get_class_names(self):
    "Returns:  the array of names from self.data_yaml"
    return ast.literal_eval(self.data_yaml.split("\n")[-1].split(":")[1].strip())

  def _itername(pre, post=""):
    """If function terminates, returns the lowest conflict-free file path
    formatted as '{pre}X{post}' where X is the string representation of a natural
    number

    args:
      pre: filename before the counter
      post: filename after the counter

    returns:
      A unique structured filename
    """
    counter = 0
    while True:
      counter += 1
      fpath = f'{pre}{counter}{post}'
      if not os.path.exists(fpath):
        return fpath

  def __hard_reset_test_dir__(datadump, keep_folder=False):
    """
    Helpful to be able to delete folders because I want to avoid name conflicts.

    Args:
      datadump: test directory. all contenst are subject to deletion
      keep_folder: if False, will also delete the folder itself.
    """
    if os.path.exists(datadump):
      shutil.rmtree(datadump)
      print(f"deleted `{datadump}`")
    else:
      print(f"`{datadump}`` did not exist")

    if keep_folder:
      os.makedirs(datadump)
      print(f"making `{datadump}`")
      assert os.path.exists(datadump)
      assert len(os.listdir(datadump)) == 0
    else:
      print(f"not making `{datadump}`")
      assert not os.path.exists(datadump)

  def read_json(self, json_file= None):
    """Reads and returns the value of a json file

    Args:
      json_file: the path to a json file. By default None is `self.config_file`

    Returns:
      the contents of the json file
    """
    if json_file is None:
      json_file = self.config_file
    with open(json_file) as config:
      raw = config.readlines()[0]
      return json.loads(raw)

  def save(self):
    "save changes made to attributes"
    with open(self.config_file, "w") as config_file:
      json.dump(self.__dict__, config_file)
