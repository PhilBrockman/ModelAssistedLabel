# AUTOGENERATED! DO NOT EDIT! File to edit: 00_config.ipynb (unless otherwise specified).

__all__ = ['Defaults']

# Cell

import json, os, shutil

class Defaults:
  """
  Makes certain variables are very accessible across the repository. The names
  of the variables and their respective values are stored in JSON format in
  `./ModelAssistedLabel config.json`

  Functions defined here are also available across this project.
  """

  def __init__(self, config_file="ModelAssistedLabel config.json"):
    self.config_file=config_file

    with open(config_file, "r") as f:
      indata = (json.load(f))
    for k,v in indata.items():
      self.__dict__[k] = v

  def prepare_YOLOv5():
    """
    * Clone repository if the YOLOv5 directory does not exist.
    * Install requirements.txt
    * Check that GPU is enabled.
    """
    # safety for re-executions
    if not os.path.exists("yolov5"):
      # clone YOLOv5 and reset to a specific git checkpoint that has been verified working
      os.system("git clone https://github.com/ultralytics/yolov5")  # clone repo
      os.system("git reset --hard 68211f72c99915a15855f7b99bf5d93f5631330f") # standardize models

    # enter the yolov5 directory
    os.chdir("yolov5")

    # install dependencies as necessary
    os.system("pip install -qr requirements.txt")  # install dependencies (ignore errors)
    import torch

    from IPython.display import Image, clear_output  # to display images
    # from utils.google_utils import gdrive_download  # to download models/datasets

    clear_output()

    if torch.cuda.is_available():
      print('Setup complete. Using torch %s %s' % (torch.__version__, torch.cuda.get_device_properties(0)))
    else:
      raise Exception("You need to enable your GPU access to this runtime environment")

    # return to parent directory
    os.chdir("..")

  def _itername(pre, post=""):
    """If function terminates, returns the lowest conflict-free file path
    formatted as '{pre}X{post}' where X is the string representation of a natural
    number

    args:
      pre: filename before the counter
      post: filename after the counter

    returns:
      A unique structured filename
    """
    counter = 0
    while True:
      counter += 1
      fpath = f'{pre}{counter}{post}'
      if not os.path.exists(fpath):
        return fpath

  def __hard_reset_test_dir__(datadump, keep_folder=False):
    """
    Helpful to be able to delete folders because I want to avoid name conflicts.

    Args:
      datadump: test directory. all contenst are subject to deletion
      keep_folder: if False, will also delete the folder itself.
    """
    if os.path.exists(datadump):
      shutil.rmtree(datadump)
      print(f"deleted `{datadump}`")
    else:
      print(f"`{datadump}`` did not exist")

    if keep_folder:
      os.makedirs(datadump)
      print(f"making `{datadump}`")
      assert os.path.exists(datadump)
      assert len(os.listdir(datadump)) == 0
    else:
      print(f"not making `{datadump}`")
      assert not os.path.exists(datadump)

  def read_json(self, json_file= None):
    """Reads and returns the value of a json file

    Args:
      json_file: the path to a json file. By default None is `self.config_file`

    Returns:
      the contents of the json file
    """
    if json_file is None:
      json_file = self.config_file
    with open(json_file) as config:
      raw = config.readlines()[0]
      return json.loads(raw)

  def save(self):
    "save changes made to attributes"
    with open(self.config_file, "w") as config_file:
      json.dump(self.__dict__, config_file)
